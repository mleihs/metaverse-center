"""Generate all 13 images for the Station Null simulation.

6 agent portraits + 7 building images via the /generate/image API.
Requires: backend running on localhost:8000, valid Replicate API key in .env.

NOTE: Agent/building IDs are auto-generated by the migration. If you re-run
`supabase start` fresh, IDs will change. Query the DB to get current IDs:
  docker exec supabase_db_velgarien-rebuild psql -U postgres -c \
    "SELECT id, name FROM agents WHERE simulation_id = '30000000-0000-0000-0000-000000000001';"
"""

import sys
import time

import requests

BASE_URL = "http://localhost:8000"
SIM_ID = "30000000-0000-0000-0000-000000000001"
SUPABASE_URL = "http://127.0.0.1:54321"

# Login credentials (test user from seed 001)
EMAIL = "admin@velgarien.dev"
PASSWORD = "velgarien-dev-2026"


def get_jwt_token() -> str:
    """Authenticate via Supabase Auth and return access token."""
    resp = requests.post(
        f"{SUPABASE_URL}/auth/v1/token?grant_type=password",
        json={"email": EMAIL, "password": PASSWORD},
        headers={
            "apikey": get_anon_key(),
            "Content-Type": "application/json",
        },
        timeout=10,
    )
    resp.raise_for_status()
    return resp.json()["access_token"]


def get_anon_key() -> str:
    """Read the Supabase anon key. Works with both old JWT and new sb_publishable keys."""
    # Standard local Supabase anon key (legacy format, still works)
    return "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24iLCJleHAiOjE5ODM4MTI5OTZ9.CRXP1A7WOeoJeXxjNni43kdQwgnWNReilDMblYTn_I0"


def get_entity_ids() -> tuple[list, list]:
    """Query the local DB for current agent/building IDs (they change on each fresh start)."""
    import subprocess
    import json

    def psql_json(query):
        """Run a psql query and return JSON results (handles multi-line text safely)."""
        wrapped = f"SELECT json_agg(t) FROM ({query}) t;"
        result = subprocess.run(
            ["docker", "exec", "supabase_db_velgarien-rebuild", "psql", "-U", "postgres", "-t", "-A", "-c", wrapped],
            capture_output=True, text=True
        )
        raw = result.stdout.strip()
        if not raw or raw == "":
            return []
        return json.loads(raw) or []

    # Agents: include character + background for portrait prompt generation
    agent_rows = psql_json(
        f"SELECT id, name, character, background FROM agents WHERE simulation_id = '{SIM_ID}' ORDER BY name"
    )
    agents = [
        (row["id"], row["name"], {
            "character": row.get("character") or "",
            "background": row.get("background") or "",
        })
        for row in agent_rows
    ]

    # Buildings: include type, condition, description, zone for image prompt generation
    building_rows = psql_json(
        f"SELECT b.id, b.name, b.building_type, b.building_condition, "
        f"LEFT(b.description, 200) as description, z.name as zone_name "
        f"FROM buildings b JOIN zones z ON b.zone_id = z.id "
        f"WHERE b.simulation_id = '{SIM_ID}' ORDER BY b.name"
    )
    buildings = [
        (row["id"], row["name"], {
            "building_type": row.get("building_type") or "",
            "building_condition": row.get("building_condition") or "",
            "description": row.get("description") or "",
            "zone_name": row.get("zone_name") or "",
        })
        for row in building_rows
    ]

    return agents, buildings


def generate_image(token: str, entity_type: str, entity_id: str, entity_name: str, extra: dict | None = None) -> str:
    """Call the /generate/image endpoint and return the image URL."""
    url = f"{BASE_URL}/api/v1/simulations/{SIM_ID}/generate/image"
    payload = {
        "entity_type": entity_type,
        "entity_id": entity_id,
        "entity_name": entity_name,
    }
    if extra:
        payload["extra"] = extra

    resp = requests.post(
        url,
        json=payload,
        headers={
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        },
        timeout=120,
    )
    resp.raise_for_status()
    data = resp.json()
    return data.get("data", {}).get("image_url", "NO URL")


def main():
    portraits_only = "--portraits-only" in sys.argv
    buildings_only = "--buildings-only" in sys.argv

    print("=== Station Null Image Generation ===\n")

    # Get current IDs from DB
    print("Querying DB for current entity IDs...")
    agents, buildings = get_entity_ids()
    print(f"  Found {len(agents)} agents, {len(buildings)} buildings\n")

    if not agents or not buildings:
        print("ERROR: No agents or buildings found. Is the DB seeded?")
        sys.exit(1)

    # Authenticate
    print("Authenticating...")
    token = get_jwt_token()
    print(f"  Got JWT token: {token[:20]}...\n")

    # Agent portraits
    if not buildings_only:
        print(f"--- Agent Portraits ({len(agents)}) ---")
        for agent_id, name, agent_data in agents:
            print(f"  Generating portrait for {name}...")
            try:
                url = generate_image(token, "agent", agent_id, name, extra=agent_data)
                print(f"    -> {url}")
            except Exception as e:
                print(f"    !! ERROR: {e}")
            time.sleep(2)  # Respect rate limits

    # Building images
    if not portraits_only:
        print(f"\n--- Building Images ({len(buildings)}) ---")
        for building_id, name, extra in buildings:
            print(f"  Generating image for {name}...")
            try:
                url = generate_image(token, "building", building_id, name, extra)
                print(f"    -> {url}")
            except Exception as e:
                print(f"    !! ERROR: {e}")
            time.sleep(2)  # Respect rate limits

    print("\n=== Done ===")


if __name__ == "__main__":
    main()
